# Disk Manager

This project aimed to implement **input/output operations** (reading and writing) of data blocks on a virtual hard drive. The execution of these operations will be handled by a disk manager, which serves as the disk access driver. On section **Task** there is a image showing the structure of the project.

## Disk Access Interface

The main task initializes the disk manager/driver through the following call:

**`int disk_mgr_init (&num_blocks, &block_size);`**

Upon returning from the call, the variable **`num_blocks`** contains the number of blocks of the initialized disk, while the variable **`block_size`** contains the size of each disk block, in bytes. This call returns 0 in case of success or -1 in case of error.

Tasks can read and write data blocks on the virtual disk through the following calls (both blocking):

**`int disk_block_read  (int block, void* buffer) ;`**

**`int disk_block_write (int block, void* buffer) ;`**

 - **`block`**: position (block number) to read or write on the disk (is between 0 and numblocks-1);
 - **`buffer`**: address of the data to be written to the disk, or where the data read from the disk should be placed; this buffer must have capacity for block_size bytes.
 - **return**: 0 in case of success or -1 in case of error.

Each task that requests a read/write operation on the disk should be suspended until the requested operation is completed. Suspended tasks should be in a wait queue associated with the disk. The read/write requests present in this queue should be serviced in the order they were generated, according to the **FCFS (First Come, First Served)** disk scheduling policy.

## The Virtual Disk

The "virtual disk" simulates the logical and temporal behavior of a real hard disk, with the following characteristics:

- The content of the virtual disk is mapped to a UNIX file in the current directory of the real machine, named default **`disk.dat`**. The content of the virtual disk is maintained from one execution to another.
- The disk contains **N** blocks of the same size. The number of disk blocks will depend on the size of the underlying file in the real system.
- As on a real disk, read/write operations are always done one block at a time. It is not possible to read or write isolated bytes, part of a block, or several blocks at the same time.
- Read/write requests made to the disk are asynchronous, i.e., they only register the requested operation, without blocking the call. The completion of each read/write operation is later indicated by the disk through a UNIX SIGUSR1 signal, which is captured and handled.
- The disk only handles one read/write at a time. While the disk is handling a request, it is in a busy state; attempts to access a busy disk return an error code.
- The disk's response time is proportional to the distance between the current position of the disk's read head and the position of the requested operation. Initially, the read head is positioned over the initial block (zero).

The code that simulates the disk is in **`disk.c`** and its access interface is defined in **`disk.h`**. Disk access is done only through the definitions present in **`disk.h`**. The definitions present in **`disk.c`** implement (simulate) the internal behavior of the disk and therefore is not used in **`ppos_disk.c`** code.

## Task

The management of disk input/output operations consists on the implementation of:

 - A task that manages the disk;
 - A function to handle the SIGUSR1 signals generated by the disk, which wakes up the disk manager task when necessary;
 - A queue of disk access requests; each request indicates the requesting task, the type of request (reading or writing), the desired block, and the address of the data buffer;
 - The disk access functions offered to tasks (**`disk_mgr_init`**, **`disk_block_read`** and **`disk_block_write`**).

The implementation of the disk manager is in the **`ppos_disk.c`** file, while its interface is in the **`ppos_disk.h`** file. The following figure shows the general structure of the code:

![Schema](https://wiki.inf.ufpr.br/maziero/lib/exe/fetch.php?cache=&media=so:ppos_disk.png)

## Code File Structure
### Tests

My implementation work with these test files:

 - **`disk.dat`**: initial content of the virtual disk, which has 256 blocks of 64 bytes each (b0, b1, …, b255), totaling 16,384 bytes. To facilitate visualization, the initial content of each block is the block number and some filler characters to complete the block.
 - **`pingpong-disco1.c`**: a single task, which reads the disk blocks in sequence and prints their content on the screen. Then, it writes on the blocks in sequence, with random characters.
 - **`pingpong-disco2.c`**: several tasks read and write on the disk simultaneously, with the aim of reversing the order of the blocks (b255, b254, …, b0).

## Implementation

The disk manager task is responsible for handling the read/write requests from the tasks and the signals generated by the disk. It is a system task, similar to the dispatcher, and has +/- the following behavior:

```
void diskDriverBody (void * args)
{
   while (true) 
   {
      // get the disk access semaphore
 
      // if it was awakened due to a signal from the disk
      if (disk generated a signal)
      {
         // wake up the task whose request was answered, the Head of the queue(FCFS)
      }
 
      // if the disk is free and there are I/O requests in the queue
      if (disk_free && (disk_queue != NULL))
      {
         // choose in the queue the request to be answered, using FCFS
         // request the disk for the I/O operation, using disk_cmd()
      }
 
      // release the disk access semaphore
 
      // suspend the current task (return to the dispatcher)
   }
}
```

The disk manager task is awakened (return to the ready_tasks queue) whenever:

 - some task requests a read/write operation on the disk; **OR**
 - the disk generates a signal indicating that the last requested operation has been completed.

Thus, the disk_block_read and disk_block_write functions follow +/- the following behavior:

```
disk_block_read (block, &buffer)
{
   // get the disk access semaphore
 
   // include the request in disk_queue
 
   if (disk manager is sleeping)
   {
      // wake up the disk manager (put it in the ready queue)
   }
 
   // release the disk access semaphore
 
   // suspend the current task (return to the dispatcher)

```

```
disk_block_write (block, &buffer)
{
   // get the disk access semaphore
 
   // include the request in disk_queue
 
   if (disk manager is sleeping)
   {
      // wake up the disk manager (put it in the ready queue)
   }
 
   // release the disk access semaphore
 
   // suspend the current task (return to the dispatcher)
}
```